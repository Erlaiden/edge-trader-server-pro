#include "json.hpp"
#include <httplib.h>
#include "../robot/jwt_middleware.cpp"
#include "../robot/db_helper.cpp"

using json = nlohmann::json;

namespace robot {
    struct RobotConfig;
    extern bool start(const std::string& apiKey, const std::string& apiSecret, const RobotConfig& cfg);
    extern void stop();
    extern bool is_running();
    extern RobotConfig get_config();
    extern double get_balance(const std::string& apiKey, const std::string& apiSecret);
    extern json get_position(const std::string& apiKey, const std::string& apiSecret, const std::string& symbol);
}

void register_robot_routes(httplib::Server& srv) {

    // GET /api/robot/status - требует JWT
    srv.Get("/api/robot/status", [&](const httplib::Request& req, httplib::Response& res){
        json out{{"ok", true}, {"running", false}, {"keys_present", false}};

        int user_id;
        if (!jwt_middleware::require_auth(req, res, user_id)) {
            return;
        }

        json keys = db::get_user_api_keys(user_id);
        out["keys_present"] = !keys.empty();
        out["running"] = robot::is_running();

        res.set_content(out.dump(), "application/json");
    });

    // POST /api/robot/keys - требует JWT
    srv.Post("/api/robot/keys", [&](const httplib::Request& req, httplib::Response& res){
        json out{{"ok", false}};

        int user_id;
        if (!jwt_middleware::require_auth(req, res, user_id)) {
            return;
        }

        try {
            json in = json::parse(req.body);
            std::string apiKey = in.value("apiKey", "");
            std::string apiSecret = in.value("apiSecret", "");
            bool testnet = in.value("testnet", false);

            if (apiKey.empty() || apiSecret.empty()) {
                out["error"] = "missing_keys";
                res.set_content(out.dump(), "application/json");
                return;
            }

            if (!db::save_user_api_keys(user_id, apiKey, apiSecret, testnet)) {
                out["error"] = "database_error";
                res.set_content(out.dump(), "application/json");
                return;
            }

            out["ok"] = true;
            res.set_content(out.dump(), "application/json");

        } catch(...) {
            out["error"] = "exception";
            res.set_content(out.dump(), "application/json");
        }
    });

    // GET /api/robot/balance - требует JWT
    srv.Get("/api/robot/balance", [&](const httplib::Request& req, httplib::Response& res){
        json out{{"ok", false}, {"balance", 0}, {"available", 0}};

        int user_id;
        if (!jwt_middleware::require_auth(req, res, user_id)) {
            return;
        }

        try {
            json keys = db::get_user_api_keys(user_id);

            if (keys.empty()) {
                res.set_content(out.dump(), "application/json");
                return;
            }

            double balance = robot::get_balance(keys["apiKey"], keys["apiSecret"]);
            out["ok"] = true;
            out["balance"] = balance;
            out["available"] = balance;
            res.set_content(out.dump(), "application/json");

        } catch(...) {
            res.set_content(out.dump(), "application/json");
        }
    });

    // GET /api/robot/position - требует JWT
    srv.Get("/api/robot/position", [&](const httplib::Request& req, httplib::Response& res){
        json out{{"ok", false}, {"position", nullptr}};

        int user_id;
        if (!jwt_middleware::require_auth(req, res, user_id)) {
            return;
        }

        try {
            json keys = db::get_user_api_keys(user_id);

            if (keys.empty()) {
                res.set_content(out.dump(), "application/json");
                return;
            }

            std::string symbol = req.get_param_value("symbol");
            if (symbol.empty()) symbol = "BTCUSDT";

            json pos = robot::get_position(keys["apiKey"], keys["apiSecret"], symbol);
            out["ok"] = true;
            out["position"] = pos;
            res.set_content(out.dump(), "application/json");

        } catch(...) {
            res.set_content(out.dump(), "application/json");
        }
    });

    // GET /api/robot/config - требует JWT
    srv.Get("/api/robot/config", [&](const httplib::Request& req, httplib::Response& res){
        json out{{"ok", false}};

        int user_id;
        if (!jwt_middleware::require_auth(req, res, user_id)) {
            return;
        }

        json config = db::get_user_config(user_id);

        out["ok"] = true;
        out["config"] = config;
        res.set_content(out.dump(), "application/json");
    });

    // POST /api/robot/config - требует JWT
    srv.Post("/api/robot/config", [&](const httplib::Request& req, httplib::Response& res){
        json out{{"ok", false}};

        int user_id;
        if (!jwt_middleware::require_auth(req, res, user_id)) {
            return;
        }

        try {
            json config = json::parse(req.body);
            bool success = db::save_user_config(user_id, config);
            
            out["ok"] = success;
            if (success) {
                std::cout << "[ROBOT_CONFIG] Saved for user_id=" << user_id << std::endl;
            }
        } catch (const std::exception& e) {
            out["error"] = e.what();
        }

        res.set_content(out.dump(), "application/json");
    });

    // GET /api/robot/pnl - требует JWT
    srv.Get("/api/robot/pnl", [&](const httplib::Request& req, httplib::Response& res){
        json out{{"ok", true}, {"today", 0}, {"total", 0}, {"unrealized", 0}};

        int user_id;
        if (!jwt_middleware::require_auth(req, res, user_id)) {
            return;
        }

        // TODO: implement real PnL calculation per user
        res.set_content(out.dump(), "application/json");
    });

    // POST /api/robot/start - требует JWT
    srv.Post("/api/robot/start", [&](const httplib::Request& req, httplib::Response& res){
        json out{{"ok", false}};

        int user_id;
        if (!jwt_middleware::require_auth(req, res, user_id)) {
            return;
        }

        try {
            json keys = db::get_user_api_keys(user_id);
            if (keys.empty()) {
                out["error"] = "keys_missing";
                res.set_content(out.dump(), "application/json");
                return;
            }

            json cfg_json = db::get_user_config(user_id);
            
            robot::RobotConfig cfg;
            cfg.symbol = cfg_json.value("symbol", "AIAUSDT");
            cfg.leverage = cfg_json.value("leverage", 10);
            cfg.balance_percent = cfg_json.value("balancePercent", 90.0);
            cfg.tp_percent = cfg_json.value("tpPercent", 2.0);
            cfg.sl_percent = cfg_json.value("slPercent", 1.0);
            cfg.min_confidence = cfg_json.value("minConfidence", 60.0);
            cfg.check_interval_sec = cfg_json.value("checkInterval", 60);
            cfg.auto_trade = cfg_json.value("autoTrade", false);

            bool success = robot::start(keys["apiKey"], keys["apiSecret"], cfg);
            out["ok"] = success;
            out["running"] = robot::is_running();
            res.set_content(out.dump(), "application/json");

        } catch(const std::exception& e) {
            out["error"] = e.what();
            res.set_content(out.dump(), "application/json");
        }
    });

    // POST /api/robot/stop - требует JWT
    srv.Post("/api/robot/stop", [&](const httplib::Request& req, httplib::Response& res){
        int user_id;
        if (!jwt_middleware::require_auth(req, res, user_id)) {
            return;
        }

        robot::stop();
        json out{{"ok", true}, {"running", false}};
        res.set_content(out.dump(), "application/json");
    });
}
